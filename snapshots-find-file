#!/bin/bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/zfs-search.sh"
source "$SCRIPT_DIR/lib/zfs-compare.sh"
source "$SCRIPT_DIR/lib/zfs-cleanup.sh"
source "$SCRIPT_DIR/lib/zfs-bench.sh"

set +f
parse_arguments "$@"
/bin/date
initialize_search_parameters

vlog "main: arguments parsed; DATASETPATH=${DATASETPATH:-}<unset> RECURSIVE=${RECURSIVE} COMPARE=${COMPARE} VERBOSE=${VERBOSE} VVERBOSE=${VVERBOSE}"

[[ $VERBOSE ]] && echo && echo -e "Gathering file inventory from snapshots based on search pattern: (${YELLOW}$FILESTR${NC})"

if [[ ${#DATASETS[@]} -eq 0 ]]; then
  echo -e "${YELLOW}No datasets found. Did you mean to include child datasets? Use the -r flag for recursive search.${NC}"
  exit 1
fi

for dataset in "${DATASETS[@]}"; do
  vlog "main: processing dataset loop entry: ${dataset}"
  process_snapshots_for_dataset "$dataset"
done
if [[ $COMPARE == 1 ]]; then
  # Benchmark mode: run legacy vs zdiff compare in-process and report timings
  if [[ "${BENCH:-0}" -eq 1 ]]; then
    bench_sff_run
    exit 0
  fi
  # shellcheck disable=SC2154
  compare_snapshot_files_to_live_dataset "$all_snapshot_files_found_tmp" "$DATASETPATH_FS" "${DATASETS[@]}"
  log_snapshot_deltas "$DATASETPATH_FS" "${DATASETS[@]}"
  # Note: Do not automatically suggest snapshot deletions during compare/search
  # unless explicitly requested via --clean-snapshots.
  echo -e "${CYAN}Comparison process complete.${NC}"

  # If user requested deletion orchestration, run the cleanup flow now.
  if [[ ${CREATE_DELETE_PLAN:-0} -eq 1 || ${ALLOW_DESTROY_SNAPS:-0} -eq 1 ]]; then
    vlog "main: running identify_and_suggest_deletion_candidates (compare mode)"
    # Respect runtime opt-out flag
    if [[ "${SKIP_PLAN:-0}" -eq 1 ]]; then
      echo -e "${YELLOW}Skipping plan generation this run (--skip-plan set).${NC}"
    else
      # Call cleanup orchestration for the same dataset path. If the plan/apply
      # flow is desired, run with `--clean-snapshots` to generate a plan; applying
      # a generated plan requires setting `ALLOW_DESTROY_SNAPS=1` in `lib/common.sh`.
      identify_and_suggest_deletion_candidates "$DATASETPATH_FS" "${DATASETS[@]}"
    fi
  fi

  # Print the human-readable comparison summary last (flat bottom of output)
  tmp_base="${LOG_DIR:-${TMPDIR:-/tmp}}"
  summary_csv="$tmp_base/comparison-summary-$TIMESTAMP.csv"
  if [[ -f "$summary_csv" ]]; then
    echo ""
    echo "--- Comparison Summary ---"
    print_comparison_summary "$summary_csv"
    echo "Wrote summary to: $summary_csv"
  fi

  echo -e "${BLUE}Exiting.${NC}"
  exit 0
fi

# Non-compare-mode cleanup invocation
if [[ $COMPARE != 1 ]]; then
  if [[ ${CREATE_DELETE_PLAN:-0} -eq 1 || ${ALLOW_DESTROY_SNAPS:-0} -eq 1 ]]; then
    vlog "main: running identify_and_suggest_deletion_candidates (non-compare mode)"
    if [[ "${SKIP_PLAN:-0}" -eq 1 ]]; then
      echo -e "${YELLOW}Skipping plan generation this run (--skip-plan set).${NC}"
    else
      identify_and_suggest_deletion_candidates "$DATASETPATH_FS" "${DATASETS[@]}"
    fi
  fi
fi

# If user requested cleanup in non-compare mode, run the deletion-candidate
# identification flow now (allow deletion orchestration outside compare mode).
## Note: cleanup already invoked above for compare and non-compare branches.
## Avoid duplicate invocation here.

# Notify the user if no files were found
if [[ ! -s "$all_snapshot_files_found_tmp" ]]; then
  echo -e "${YELLOW}No files found matching the specified criteria in the dataset(s).${NC}"
fi

rm -f "$all_snapshot_files_found_tmp"
echo ...completed.