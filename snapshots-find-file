#!/bin/bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/zfs-search.sh"
source "$SCRIPT_DIR/lib/zfs-compare.sh"
source "$SCRIPT_DIR/lib/zfs-cleanup.sh"

set +f
parse_arguments "$@"
/bin/date
initialize_search_parameters

[[ $VERBOSE ]] && echo && echo -e "Gathering file inventory from snapshots based on search pattern: (${RED}$FILESTR${NC})"

if [[ ${#DATASETS[@]} -eq 0 ]]; then
  echo -e "${YELLOW}No datasets found. Did you mean to include child datasets? Use the -r flag for recursive search.${NC}"
  exit 1
fi

for dataset in "${DATASETS[@]}"; do
  process_snapshots_for_dataset "$dataset"
done

if [[ $COMPARE == 1 ]]; then
  # shellcheck disable=SC2154
  compare_snapshot_files_to_live_dataset "$all_snapshot_files_found_tmp" "$DATASETPATH_FS" "${DATASETS[@]}"
  log_snapshot_deltas "$DATASETPATH_FS" "${DATASETS[@]}"
  # Note: Do not automatically suggest snapshot deletions during compare/search.
  # To run deletion candidate analysis, invoke the cleanup step explicitly.
  echo -e "${BLUE}Comparison process complete. Exiting.${NC}"
  exit 0
fi

# Notify the user if no files were found
if [[ ! -s "$all_snapshot_files_found_tmp" ]]; then
  echo -e "${YELLOW}No files found matching the specified criteria in the dataset(s).${NC}"
fi

rm -f "$all_snapshot_files_found_tmp"
echo ...completed.